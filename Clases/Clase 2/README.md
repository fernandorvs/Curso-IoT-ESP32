# Clase 2 - Control Avanzado y Programaci√≥n No Bloqueante

## üìö Contenido de la Clase

Esta es la segunda clase del curso **Internet de las Cosas con ESP32** de la Universidad Nacional de Santiago del Estero. Se enfoca en t√©cnicas fundamentales para crear sistemas embebidos m√°s robustos y profesionales.

## üéØ Objetivos de Aprendizaje

Al finalizar esta clase, los estudiantes ser√°n capaces de:
- ‚úÖ Controlar la intensidad de LEDs usando PWM (Modulaci√≥n por Ancho de Pulso)
- ‚úÖ Aplicar correcci√≥n gamma para transiciones visuales naturales
- ‚úÖ Leer pulsadores con t√©cnicas de antirrebote (debounce) confiables
- ‚úÖ Implementar programaci√≥n no bloqueante con `millis()`
- ‚úÖ Combinar m√∫ltiples tareas en ejecuci√≥n simult√°nea
- ‚úÖ Dise√±ar m√°quinas de estado finito (FSM) para sistemas multitarea
- ‚úÖ Escribir c√≥digo escalable y profesional para sistemas embebidos

## üìã Tabla de Contenidos

1. [Teor√≠a Cubierta](#-teor√≠a-cubierta)
2. [Proyectos Incluidos](#-proyectos-incluidos)
   - [2.1 - LED con PWM](#21---led-con-pwm)
   - [2.2 - Pulsador con Antirrebote](#22---pulsador-con-antirrebote)
   - [2.3 - Blink No Bloqueante](#23---blink-no-bloqueante)
   - [2.4 - Pulsador No Bloqueante](#24---pulsador-no-bloqueante)
   - [2.5 - Blink + Pulsador No Bloqueantes](#25---blink--pulsador-no-bloqueantes)
   - [2.6 - FSM M√°quina de Estado](#26---fsm-m√°quina-de-estado)
3. [Conceptos T√©cnicos Importantes](#-conceptos-t√©cnicos-importantes)
5. [C√≥mo Ejecutar los Proyectos](#-c√≥mo-ejecutar-los-proyectos)
6. [Progresi√≥n del Aprendizaje](#-progresi√≥n-del-aprendizaje)
7. [Ejercicios Propuestos](#-ejercicios-propuestos)
8. [Documentaci√≥n de Referencia](#-documentaci√≥n-de-referencia)

## üìñ Teor√≠a Cubierta

### 1. Control de LED con PWM
- **Concepto de PWM**: Simulaci√≥n de se√±ales anal√≥gicas con pulsos digitales
- **Duty Cycle**: Porcentaje de tiempo en HIGH (0-100%)
- **Frecuencia**: Ciclos por segundo para control suave
- **Hardware ESP32**: 16 canales PWM independientes, hasta 20 bits de resoluci√≥n
- **Correcci√≥n Gamma**: Para transiciones visuales m√°s naturales

### 2. Lectura de Pulsadores con Antirrebote
- **Problema del rebote**: M√∫ltiples lecturas por una sola pulsaci√≥n
- **Antirrebote por software**: T√©cnica de temporizaci√≥n para filtrar ruido
- **INPUT_PULLUP**: Resistencias pull-up internas del ESP32
- **Detecci√≥n de flancos**: Identificar cambios de estado confiables

### 3. Programaci√≥n No Bloqueante
- **Problema de delay()**: Bloquea toda la ejecuci√≥n del programa
- **funci√≥n millis()**: Contador de tiempo desde el arranque
- **T√©cnica de temporizaci√≥n**: Comparar tiempos para ejecutar acciones
- **Multitarea cooperativa**: M√∫ltiples procesos en un solo hilo

### 4. M√°quinas de Estado Finito (FSM)
- **Concepto de estado**: Situaci√≥n actual del sistema
- **Transiciones**: Cambios entre estados por eventos
- **Estructura switch-case**: Implementaci√≥n pr√°ctica en C++
- **Flags de eventos**: Comunicaci√≥n entre procesos

## üíª Proyectos Incluidos

### 2.1 - LED con PWM
**Ubicaci√≥n**: `C√≥digo/2.1 Led con PWM/`  
**üìÑ [Ver README completo](C√≥digo/2.1%20Led%20con%20PWM/README.md)**

**Descripci√≥n**: Control de intensidad de LED con efecto fade in/out suave usando correcci√≥n gamma.

**Caracter√≠sticas**:
- PWM a 5 kHz con resoluci√≥n de 8 bits
- Efecto de respiraci√≥n autom√°tico
- Correcci√≥n gamma para transiciones naturales
- Explicaci√≥n detallada de duty cycle y frecuencia

```cpp
// Configuraci√≥n PWM
ledcSetup(0, 5000, 8);        // Canal 0, 5kHz, 8 bits
ledcAttachPin(PIN_LED, 0);    // GPIO2 al canal 0
ledcWrite(0, dutyCycle);      // Escribir valor PWM
```

**Aprender√°s**: Control anal√≥gico, PWM, correcci√≥n gamma, hardware LEDC del ESP32

---

### 2.2 - Pulsador con Antirrebote
**Ubicaci√≥n**: `C√≥digo/2.2 Pulsador con Antirrebote/`  
**üìÑ [Ver README completo](C√≥digo/2.2%20Pulsador%20con%20Antirrebote/README.md)**

**Descripci√≥n**: Lectura confiable de bot√≥n que invierte el estado del LED con cada pulsaci√≥n usando antirrebote **bloqueante**.

**Caracter√≠sticas**:
- Antirrebote por delay de 50ms
- Detecci√≥n de flanco de bajada
- Espera activa hasta soltar el bot√≥n
- INPUT_PULLUP para bot√≥n BOOT integrado

```cpp
// Antirrebote b√°sico bloqueante
if (digitalRead(BUTTON_PIN) == LOW) {
    delay(50);                           // Espera estabilizaci√≥n
    if (digitalRead(BUTTON_PIN) == LOW) {
        digitalWrite(LED_PIN, !digitalRead(LED_PIN));
        while (digitalRead(BUTTON_PIN) == LOW); // Espera soltar
    }
}
```

**Aprender√°s**: Rebote mec√°nico, pull-up interno, antirrebote por software, limitaciones del c√≥digo bloqueante

---

### 2.3 - Blink No Bloqueante
**Ubicaci√≥n**: `C√≥digo/2.3 Blink no bloqueante/`  
**üìÑ [Ver README completo](C√≥digo/2.3%20Blink%20no%20bloqueante/README.md)**

**Descripci√≥n**: LED parpadeante que no bloquea el programa principal usando `millis()`.

**Caracter√≠sticas**:
- Usa `millis()` en lugar de `delay()`
- Permite ejecutar otras tareas simult√°neamente
- Control de tiempo preciso sin bloqueos
- Manejo correcto de overflow de millis()

```cpp
// T√©cnica no bloqueante
unsigned long ahora = millis();
if (ahora - lastBlink >= BLINK_MS) {
    lastBlink = ahora;
    ledState = !ledState;
    digitalWrite(PIN_LED, ledState);
}
// Contin√∫a inmediatamente sin esperar
```

**Aprender√°s**: Programaci√≥n no bloqueante, funci√≥n millis(), marcas de tiempo, intervalos temporales

---

### 2.4 - Pulsador No Bloqueante
**Ubicaci√≥n**: `C√≥digo/2.4 Pulsador no bloqueante/`  
**üìÑ [Ver README completo](C√≥digo/2.4%20Pulsador%20no%20bloqueante/README.md)**

**Descripci√≥n**: Lectura de bot√≥n con antirrebote **no bloqueante** usando `millis()`.

**Caracter√≠sticas**:
- Antirrebote temporal con `millis()`
- No bloquea otras funciones
- Detecci√≥n confiable de cambios de estado
- Reporta "PRESIONADO" y "SUELTO" por Serial

```cpp
// Antirrebote no bloqueante
int r = digitalRead(BUTTON_PIN);
if (r != stable && millis() - lastDebounce > 50) {
    lastDebounce = millis();
    stable = r;
    Serial.println(stable == LOW ? "PRESIONADO" : "SUELTO");
}
```

**Aprender√°s**: Antirrebote no bloqueante, detecci√≥n de cambios de estado, operador ternario, patr√≥n reutilizable

---

### 2.5 - Blink + Pulsador No Bloqueantes
**Ubicaci√≥n**: `C√≥digo/2.5 Blink + Pulsador no bloqueantes/`  
**üìÑ [Ver README completo](C√≥digo/2.5%20Blink%20+%20Pulsador%20no%20bloqueantes/README.md)**

**Descripci√≥n**: Combinaci√≥n de LED parpadeante y lectura de bot√≥n ejecut√°ndose **simult√°neamente e independientemente**.

**Caracter√≠sticas**:
- Dos tareas no bloqueantes en paralelo
- LED parpadea cada 500ms
- Bot√≥n detecta pulsaciones en tiempo real
- Base para sistemas multitarea cooperativos

```cpp
void loop() {
    // Tarea 1: Blink no bloqueante
    if (millis() - lastBlink >= BLINK_MS) {
        lastBlink = millis();
        ledState = !ledState;
        digitalWrite(PIN_LED, ledState);
    }
    
    // Tarea 2: Pulsador no bloqueante
    int r = digitalRead(BUTTON_PIN);
    if (r != stable && millis() - lastDebounce > 50) {
        lastDebounce = millis();
        stable = r;
        Serial.println(stable == LOW ? "PRESIONADO" : "SUELTO");
    }
}
```

**Aprender√°s**: Multitarea cooperativa, independencia de tareas, escalabilidad, dise√±o modular

---

### 2.6 - FSM M√°quina de Estado
**Ubicaci√≥n**: `C√≥digo/2.6 FSM M√°quina de estado/`  
**üìÑ [Ver README completo](C√≥digo/2.6%20FSM%20M√°quina%20de%20estado/README.md)**

**Descripci√≥n**: Sistema de control de LED con tres estados diferentes controlados por bot√≥n usando **M√°quina de Estados Finitos (FSM)**.

**Estados del sistema**:
1. **STATE_OFF**: LED apagado
2. **STATE_ON**: LED encendido fijo
3. **STATE_BLINK**: LED parpadeando

**Transiciones**:
- OFF ‚Üí ON ‚Üí BLINK ‚Üí OFF (c√≠clico con cada pulsaci√≥n del bot√≥n)

```cpp
// Estructura FSM
switch (state) {
    case STATE_OFF:
        digitalWrite(PIN_LED, LOW);
        if (buttonPressed) {
            buttonPressed = 0;
            state = STATE_ON;
        }
        break;
    
    case STATE_ON:
        digitalWrite(PIN_LED, HIGH);
        if (buttonPressed) {
            buttonPressed = 0;
            state = STATE_BLINK;
        }
        break;
    
    case STATE_BLINK:
        // L√≥gica de parpadeo no bloqueante
        if (millis() - lastBlink >= BLINK_MS) {
            lastBlink = millis();
            ledState = !ledState;
            digitalWrite(PIN_LED, ledState);
        }
        if (buttonPressed) {
            buttonPressed = 0;
            state = STATE_OFF;
        }
        break;
}
```

**Aprender√°s**: FSM, estados y transiciones, patr√≥n flag + FSM, arquitectura profesional de software embebido

## üîß Conceptos T√©cnicos Importantes

### PWM en ESP32
- **Hardware LEDC**: Controlador dedicado para PWM
- **16 canales disponibles**: Permite controlar m√∫ltiples LEDs/motores
- **Frecuencias configurables**: 1Hz hasta >40MHz
- **Resoluci√≥n variable**: 1-20 bits seg√∫n frecuencia

### Funci√≥n millis()
- **Contador de 32 bits**: Cuenta milisegundos desde el arranque
- **Desbordamiento**: Regresa a 0 despu√©s de ~49 d√≠as
- **Resoluci√≥n**: 1 milisegundo
- **No bloqueante**: Contin√∫a contando en background

### T√©cnicas de Temporizaci√≥n
```cpp
// Patr√≥n b√°sico no bloqueante
unsigned long tiempoAnterior = 0;
const unsigned long intervalo = 1000;

if (millis() - tiempoAnterior >= intervalo) {
    tiempoAnterior = millis();
    // Ejecutar acci√≥n cada 1 segundo
}
```

## üöÄ C√≥mo Ejecutar los Proyectos

### Requisitos de Hardware
- Placa ESP32
- LED externo + resistencia 220Œ© (opcional, usa el integrado)
- Bot√≥n pulsador + resistencia 10kŒ© pull-up (opcional, usa GPIO0/BOOT)
- Protoboard y cables

### Configuraci√≥n B√°sica
```cpp
// Configuraci√≥n com√∫n en todos los proyectos
#define PIN_LED 2      // LED integrado
#define BUTTON_PIN 0   // Bot√≥n BOOT integrado
```

### Pasos para cada proyecto
1. **Abrir proyecto** en PlatformIO
2. **Conectar ESP32** via USB
3. **Compilar y subir** (Ctrl+Alt+U)
4. **Abrir Serial Monitor** para mensajes de debug
5. **Probar funcionalidad** seg√∫n descripci√≥n del proyecto

## üéì Progresi√≥n del Aprendizaje

### Nivel B√°sico ‚Üí Intermedio ‚Üí Avanzado

1. **2.1 PWM**: Control anal√≥gico b√°sico con correcci√≥n gamma
2. **2.2 Antirrebote**: Lectura confiable de entradas (bloqueante)
3. **2.3 Blink no bloqueante**: Introducci√≥n a programaci√≥n sin delay()
4. **2.4 Pulsador no bloqueante**: Antirrebote sin bloquear el programa
5. **2.5 Multitarea**: Dos tareas independientes simult√°neas
6. **2.6 FSM**: Arquitectura profesional con m√°quina de estados

### Conceptos que se construyen
- **Clase 1**: B√°sicos digitales (HIGH/LOW, delay())
- **Clase 2**: Control anal√≥gico (PWM) + programaci√≥n no bloqueante + FSM
- **Pr√≥ximas clases**: Sensores + comunicaci√≥n + IoT

### Ruta de Aprendizaje Recomendada
```
Clase 1: Blink b√°sico
    ‚Üì
2.1: Controlar brillo (PWM)
    ‚Üì
2.2: Leer bot√≥n confiable (antirrebote bloqueante)
    ‚Üì
2.3: Parpadear sin bloquear (millis())
    ‚Üì
2.4: Bot√≥n sin bloquear (antirrebote no bloqueante)
    ‚Üì
2.5: Combinar tareas (multitarea cooperativa)
    ‚Üì
2.6: Controlar con estados (FSM)
    ‚Üì
Clase 3: Sensores anal√≥gicos
```

## üîç Ejercicios Propuestos

### Ejercicio 1: PWM Variable con Potenci√≥metro
Modificar el proyecto 2.1 para controlar la velocidad del fade con un potenci√≥metro conectado a un pin ADC. El potenci√≥metro determinar√° el valor de `delay()` entre incrementos.

### Ejercicio 2: M√∫ltiples LEDs No Bloqueantes
Crear un programa con 3 LEDs que parpadeen a diferentes frecuencias (200ms, 500ms, 1000ms) usando el patr√≥n no bloqueante del proyecto 2.3.

### Ejercicio 3: FSM Extendida
Expandir la FSM del proyecto 2.6 para incluir:
- Un cuarto estado: **STATE_FAST_BLINK** (parpadeo r√°pido a 100ms)
- Secuencia: OFF ‚Üí ON ‚Üí BLINK ‚Üí FAST_BLINK ‚Üí OFF

### Ejercicio 4: Control por Serial
Modificar el proyecto 2.6 para recibir comandos por Serial Monitor:
- '0' = STATE_OFF
- '1' = STATE_ON  
- '2' = STATE_BLINK

### Ejercicio 5: Bot√≥n con Pulsaci√≥n Larga
Expandir el proyecto 2.4 para detectar:
- **Pulsaci√≥n corta** (<1 segundo): imprime "CORTA"
- **Pulsaci√≥n larga** (‚â•1 segundo): imprime "LARGA"

### Ejercicio 6: Sistema de Alarma Simple
Combinar conceptos de 2.5 y 2.6 para crear:
- Estado DESARMADO (LED apagado)
- Estado ARMADO (LED parpadea lento)
- Estado ALARMA (LED parpadea r√°pido + buzzer)
- Transiciones con bot√≥n

## üìö Documentaci√≥n de Referencia

### Documentaci√≥n de la Clase
- **[Manual completo de la Clase 2](Docs/Curso_IoT_ESP32_UNSE_Clase_2.pdf)** - Documento oficial del curso

### README por Proyecto
- **[2.1 Led con PWM](C√≥digo/2.1%20Led%20con%20PWM/README.md)** - Control de brillo y correcci√≥n gamma
- **[2.2 Pulsador con Antirrebote](C√≥digo/2.2%20Pulsador%20con%20Antirrebote/README.md)** - Antirrebote bloqueante
- **[2.3 Blink no bloqueante](C√≥digo/2.3%20Blink%20no%20bloqueante/README.md)** - Introducci√≥n a millis()
- **[2.4 Pulsador no bloqueante](C√≥digo/2.4%20Pulsador%20no%20bloqueante/README.md)** - Antirrebote no bloqueante
- **[2.5 Blink + Pulsador no bloqueantes](C√≥digo/2.5%20Blink%20+%20Pulsador%20no%20bloqueantes/README.md)** - Multitarea
- **[2.6 FSM M√°quina de estado](C√≥digo/2.6%20FSM%20M√°quina%20de%20estado/README.md)** - Estados finitos

### Referencias T√©cnicas
- [ESP32 LEDC Documentation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/ledc.html) - Documentaci√≥n oficial de PWM
- [Arduino millis() Reference](https://www.arduino.cc/reference/en/language/functions/time/millis/) - Funci√≥n de temporizaci√≥n
- [Finite State Machines in Embedded Systems](https://barrgroup.com/embedded-systems/how-to/state-machines-event-driven-systems) - Teor√≠a de FSM

## üéØ Puntos Clave para Recordar

### ‚úÖ Buenas Pr√°cticas

**Programaci√≥n No Bloqueante:**
- **Evitar delay()** en programas multitarea
- **Usar millis()** para medir tiempo sin bloquear
- **Implementar flags** para comunicaci√≥n entre procesos
- **Cada tarea verifica su propio tiempo** independientemente

**PWM y Control Anal√≥gico:**
- **Usar const para frecuencias** y resoluciones
- **Aplicar correcci√≥n gamma** para transiciones visuales naturales
- **Documentar el canal PWM** utilizado

**M√°quinas de Estado:**
- **Estructurar FSMs** con switch-case claros
- **Comentar transiciones** de estado y eventos
- **Definir estados con #define** o enum para legibilidad
- **Cada estado hace una cosa** espec√≠fica

**Antirrebote:**
- **50ms es t√≠pico** para antirrebote de botones
- **Verificar dos veces** el estado del bot√≥n
- **Usar variables de estado estable** para comparaci√≥n

### ‚ö†Ô∏è Errores Comunes

**Temporizaci√≥n:**
- ‚ùå Olvidar actualizar `lastTime = millis()` despu√©s de verificar el intervalo
- ‚ùå Usar `delay()` mezclado con c√≥digo no bloqueante
- ‚ùå No manejar el overflow de millis() (aunque la resta funciona bien)
- ‚ùå Comparar `millis() == valor` en lugar de `millis() >= valor`

**M√°quinas de Estado:**
- ‚ùå Olvidar resetear flags de eventos despu√©s de usarlos
- ‚ùå Estados sin salida en FSMs (loops infinitos sin transici√≥n)
- ‚ùå No incluir `break` al final de cada case
- ‚ùå Olvidar case `default` para estados no definidos

**Pulsadores:**
- ‚ùå Leer botones sin antirrebote (lecturas m√∫ltiples)
- ‚ùå No configurar pull-up/pull-down (lecturas flotantes)
- ‚ùå Procesar pulsaci√≥n en cada loop (multiplicar eventos)

**PWM:**
- ‚ùå Usar el mismo canal PWM para m√∫ltiples pines
- ‚ùå Frecuencias muy altas con resoluci√≥n muy alta (limitaci√≥n hardware)
- ‚ùå No apagar PWM antes de reasignar el canal

## üîÑ Conexi√≥n con Otras Clases

### üìñ Desde Clase 1
Conceptos previos necesarios:
- ‚úÖ Configuraci√≥n de GPIO con `pinMode()`
- ‚úÖ Estructura b√°sica `setup()` / `loop()`
- ‚úÖ Control digital con `digitalWrite()` y `digitalRead()`
- ‚úÖ Uso b√°sico de `delay()` (para luego evitarlo)
- ‚úÖ Constantes con `#define`
- ‚úÖ Serial Monitor b√°sico

### üìñ Hacia Clase 3
Fundamentos que preparan para:
- üîú **Lectura de sensores anal√≥gicos** (ADC) de forma no bloqueante
- üîú **Filtros digitales** aplicados con temporizaci√≥n precisa
- üîú **M√∫ltiples sensores** ley√©ndose simult√°neamente
- üîú **Comunicaci√≥n de datos** por Serial de forma eficiente
- üîú **Displays OLED** actualiz√°ndose sin bloquear sensores

### üìñ Hacia Clase 4
Conceptos que escalan a IoT:
- üîú **Servidor web** respondiendo peticiones sin bloquear lecturas de sensores
- üîú **WiFi conectado** mientras se mantiene control local
- üîú **APIs REST** con FSM para control de dispositivos
- üîú **Dashboard en tiempo real** con actualizaciones no bloqueantes

### üéØ Habilidades Adquiridas
Despu√©s de esta clase podr√°s:
- ‚úÖ Crear sistemas que hacen m√∫ltiples cosas al mismo tiempo
- ‚úÖ Controlar actuadores con precisi√≥n (PWM)
- ‚úÖ Leer entradas digitales de forma confiable (antirrebote)
- ‚úÖ Dise√±ar arquitecturas de software escalables (FSM)
- ‚úÖ Escribir c√≥digo profesional no bloqueante

## üßë‚Äçüè´ Instructor

**Ing. Fernando Ra√∫l Vera Suasn√°var**  
Universidad Nacional de Santiago del Estero  
A√±o 2025

---

## üìä Comparaci√≥n Visual de Conceptos

### Bloqueante vs No Bloqueante

| Aspecto | C√≥digo Bloqueante | C√≥digo No Bloqueante |
|---------|-------------------|----------------------|
| **Funci√≥n principal** | `delay()` | `millis()` |
| **Ejecuci√≥n** | Secuencial (una cosa a la vez) | Cooperativa (m√∫ltiples tareas) |
| **CPU durante espera** | ‚ùå Bloqueado, no hace nada | ‚úÖ Libre, puede hacer otras cosas |
| **Complejidad** | ‚≠ê Simple | ‚≠ê‚≠ê‚≠ê M√°s complejo |
| **Escalabilidad** | ‚ùå Dif√≠cil agregar tareas | ‚úÖ F√°cil agregar tareas |
| **Respuesta a eventos** | ‚ùå Retrasada | ‚úÖ Inmediata |
| **Ejemplo** | Proyecto 2.2 | Proyectos 2.3 - 2.6 |

### Progresi√≥n de Complejidad

```
Complejidad Baja  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  Complejidad Alta
    ‚îÇ                ‚îÇ              ‚îÇ             ‚îÇ             ‚îÇ
2.1 PWM          2.2 Bot√≥n      2.3 Blink     2.5 Multi    2.6 FSM
(Control         (Antirrebote   no-block      tarea        (Estados
anal√≥gico)       bloqueante)    (millis)      (Paralelo)   secuenciales)
                                                ‚îÇ
                                            2.4 Bot√≥n
                                            no-block
```

### Casos de Uso Recomendados

| Proyecto | Mejor para | No recomendado para |
|----------|-----------|---------------------|
| **2.1 PWM** | Control suave de brillo, motores, servos | Se√±ales digitales simples ON/OFF |
| **2.2 Antirrebote bloqueante** | Prototipado r√°pido, proyectos simples | Sistemas que requieren multitarea |
| **2.3 Blink no bloqueante** | Base para cualquier proyecto con temporizadores | Proyectos donde delay() es aceptable |
| **2.4 Pulsador no bloqueante** | Interfaces de usuario, sistemas reactivos | - |
| **2.5 Multitarea** | Sistemas con sensores + actuadores + UI | Proyectos muy simples |
| **2.6 FSM** | Control de procesos, men√∫s, protocolos | L√≥gica muy simple sin estados claros |

---

*¬°Has dominado las t√©cnicas fundamentales para sistemas embebidos profesionales! Ahora puedes crear dispositivos que hacen m√∫ltiples tareas simult√°neamente de manera confiable.*